/**           __  __
 *    _____ _/ /_/ /_    Computational Intelligence Library (CIlib)
 *   / ___/ / / / __ \   (c) CIRG @ UP
 *  / /__/ / / / /_/ /   http://cilib.net
 *  \___/_/_/_/_.___/
 */
package net.sourceforge.cilib.pso.iterationstrategies;

import static com.google.common.base.Preconditions.checkState;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import net.sourceforge.cilib.algorithm.AbstractAlgorithm;
import net.sourceforge.cilib.algorithm.population.IterationStrategy;
import net.sourceforge.cilib.controlparameter.ConstantControlParameter;
import net.sourceforge.cilib.controlparameter.ControlParameter;
import net.sourceforge.cilib.entity.behaviour.Behaviour;
import net.sourceforge.cilib.entity.Entity;
import net.sourceforge.cilib.problem.boundaryconstraint.BoundaryConstraint;
import net.sourceforge.cilib.pso.PSO;
import net.sourceforge.cilib.pso.hpso.detectionstrategies.BehaviorChangeTriggerDetectionStrategy;
import net.sourceforge.cilib.pso.hpso.detectionstrategies.PersonalBestStagnationDetectionStrategy;
import net.sourceforge.cilib.pso.iterationstrategies.SynchronousIterationStrategy;
import net.sourceforge.cilib.pso.particle.Particle;
import net.sourceforge.cilib.util.selection.recipes.Selector;
import net.sourceforge.cilib.util.selection.recipes.TournamentSelector;
import net.sourceforge.cilib.pso.hpso.HeterogeneousIterationStrategy;
import net.sourceforge.cilib.algorithm.initialisation.BehaviourGeneratorPopulationInitializationStrategy;
/**
 * Uses the initial behaviour pool generated by the initialization to update the behaviours over time.
 */
public class SelfAdaptiveIterationStrategy implements IterationStrategy<PSO>, HeterogeneousIterationStrategy {
    private IterationStrategy<PSO> iterationStrategy;
    private BehaviorChangeTriggerDetectionStrategy detectionStrategy;
    private Selector<Behaviour> behaviorSelectionRecipe;
    private List<Behaviour> behaviorPool;
    private Map<Behaviour, List<Integer>> successCounters;
    private Map<Behaviour, List<Integer>> iterationCounters;
    private ControlParameter windowSize;

    /**
     * Default constructor.
     */
    public SelfAdaptiveIterationStrategy() {
        this.iterationStrategy = new SynchronousIterationStrategy();
        this.detectionStrategy = new PersonalBestStagnationDetectionStrategy();
        this.behaviorSelectionRecipe = new TournamentSelector<Behaviour>();
        this.windowSize = ConstantControlParameter.of(10);
        this.successCounters = new HashMap<Behaviour, List<Integer>>();
        this.iterationCounters = new HashMap<Behaviour, List<Integer>>();
        ((TournamentSelector<Behaviour>) this.behaviorSelectionRecipe).setTournamentSize(ConstantControlParameter.of(0.2));
    }

    /**
     * Create a copy of the provided instance.
     * @param copy The instance to copy.
     */
    public SelfAdaptiveIterationStrategy(SelfAdaptiveIterationStrategy copy) {
        this.iterationStrategy = copy.iterationStrategy.getClone();
        this.detectionStrategy = copy.detectionStrategy.getClone();
        this.behaviorSelectionRecipe = copy.behaviorSelectionRecipe;
        this.behaviorPool = new ArrayList<Behaviour>(copy.behaviorPool);
        this.successCounters = new HashMap<Behaviour, List<Integer>>(copy.successCounters);
        this.iterationCounters = new HashMap<Behaviour, List<Integer>>(copy.iterationCounters); 
        this.windowSize = copy.windowSize;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public SelfAdaptiveIterationStrategy getClone() {
        return new SelfAdaptiveIterationStrategy(this);
    }

    /**
     * <ol>
     *   <li>For each particle:</li>
     *   <li>Check if particle must change its behavior</li>
     *   <li>If particle must change its behavior:</li>
     *   <ol>
     *     <li>Assign a new behavior to the particle from the behavior pool</li>
     *   </ol>
     *   <li>Perform normal iteration</li>
     *   <li>Update success counters</li>
     * </ol>
     */
    @Override
    public void performIteration(PSO algorithm) {
        //checkState(behaviorPool.size() > 0, "You must add particle behaviors to the behavior pool first.");
        checkState((int) windowSize.getParameter() > 0, "N must be bigger than 0.");

        //reset for algorithm
        if (AbstractAlgorithm.get().getIterations() == 0) {
            //get the behaviour pool from the initialization strategy
            BehaviourGeneratorPopulationInitializationStrategy initialization = (BehaviourGeneratorPopulationInitializationStrategy) algorithm.getInitialisationStrategy();
            this.behaviorPool = initialization.getDelegate().getBehaviorPool();
        	
        	for(Behaviour pb : behaviorPool) {
                addToSuccessCounters(pb);
                addToIterationCounters(pb);
            }
        }
        
        checkState(behaviorPool.size() > 0, "Behaviour pool is empty.");

        for(Behaviour pb : behaviorPool) {
            int sum = 0;
            int iters = 0;
            for(int i = 0; i < (int) windowSize.getParameter(); i++) {
                sum += successCounters.get(pb).get(i);
                iters += iterationCounters.get(pb).get(i);
            }

            pb.setSuccessCounter(sum);
            pb.setIterationCounter(iters);
        }

        //here is where I can update the behaviours if need be!
        //find the worst performing and remove..or replace.
        //behaviourUpdateStrategy -> detection and replacement
        
        Behaviour behavior;
        for(Entity e : algorithm.getTopology()) {
            Particle p = (Particle)e;
            if (detectionStrategy.detect(p)) {
            	Behaviour orig = p.getBehaviour();
            	//only allow behaviours that are as good or better than the current to be selected
            	//do{
            		behavior = behaviorSelectionRecipe.on(behaviorPool).select();
            	//} while(behavior.compareTo(orig) < 0);
            	
                behavior.incrementSelectedCounter();
                p.setBehaviour(behavior);
            }
        }

        for(Behaviour pb : behaviorPool) {
            pb.resetSuccessCounter();
            pb.resetIterationCounter();
        }

        iterationStrategy.performIteration(algorithm);

        for(Entity e : algorithm.getTopology()) {
            Particle p = (Particle)e;
            p.getBehaviour().incrementIterationCounter();
        }
        
        for(Behaviour pb : behaviorPool) {
            successCounters.get(pb).set(AbstractAlgorithm.get().getIterations()%(int)windowSize.getParameter(), pb.getSuccessCounter());
            iterationCounters.get(pb).set(AbstractAlgorithm.get().getIterations()%(int)windowSize.getParameter(), pb.getIterationCounter());
        }
    }

    /**
     * Get the current {@linkplain IterationStrategy}.
     * @return The current {@linkplain IterationStrategy}.
     */
    public IterationStrategy<PSO> getIterationStrategy() {
        return iterationStrategy;
    }

    /**
     * Set the {@linkplain IterationStrategy} to be used.
     * @param iterationStrategy The value to set.
     */
    public void setIterationStrategy(IterationStrategy<PSO> iterationStrategy) {
        this.iterationStrategy = iterationStrategy;
    }

    /**
     * Get the currently defined
     * {@linkplain BehaviorChangeTriggerDetectionStrategy stagnation detection strategy}.
     *
     * @return  The current
     *          {@linkplain BehaviorChangeTriggerDetectionStrategy stagnation detection strategy}.
     */
    public BehaviorChangeTriggerDetectionStrategy getDetectionStrategy() {
        return detectionStrategy;
    }

    /**
     * Set the {@linkplain BehaviorChangeTriggerDetectionStrategy stagnation detection strategy}
     * to be used.
     *
     * @param strategy  The {@linkplain BehaviorChangeTriggerDetectionStrategy stagnation detection strategy}
     *                  to set.
     */
    public void setDetectionStrategy(BehaviorChangeTriggerDetectionStrategy strategy) {
        this.detectionStrategy = strategy;
    }

    /**
     * Get the currently defined {@linkplain Selector},
     * @return The current {@linkplain Selector}.
     */
    public Selector<Behaviour> getSelectionRecipe() {
        return behaviorSelectionRecipe;
    }

    /**
     * Set the current {@linkplain Selector} to use.
     * @param recipe The {@linkplain Selector} to set.
     */
    public void setSelectionRecipe(Selector<Behaviour> recipe) {
        this.behaviorSelectionRecipe = recipe;
    }

    private void addToSuccessCounters(Behaviour behavior) {
        ArrayList<Integer> zeroList = new ArrayList<Integer>((int)windowSize.getParameter());
        for(int i = 0; i < (int) windowSize.getParameter(); i++) {
            zeroList.add(0);
        }

        successCounters.put(behavior, zeroList);
    }
    
    private void addToIterationCounters(Behaviour behavior) {
        ArrayList<Integer> zeroList = new ArrayList<Integer>((int)windowSize.getParameter());
        for(int i = 0; i < (int) windowSize.getParameter(); i++) {
            zeroList.add(0);
        }

        iterationCounters.put(behavior, zeroList);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void addBehavior(Behaviour behavior) {
        behaviorPool.add(behavior);
    }

    /**
     * Sets the number of iterations for which to keep success counters.
     * @param n The number of iterations
     */
    public void setWindowSize(ControlParameter n) {
        this.windowSize = n;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setBehaviorPool(List<Behaviour> pool) {
        behaviorPool = pool;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<Behaviour> getBehaviorPool() {
        return behaviorPool;
    }

    @Override
    public BoundaryConstraint getBoundaryConstraint() {
        return this.iterationStrategy.getBoundaryConstraint();
    }

    @Override
    public void setBoundaryConstraint(BoundaryConstraint boundaryConstraint) {
        this.iterationStrategy.setBoundaryConstraint(boundaryConstraint);
    }
}
